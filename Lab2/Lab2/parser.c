#include <stdio.h>

#include "parser.h"
#include "front.h"

static void error();

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <rexp> {( && | || ) <rexp>}
 */
void expr()
{
    printf("Enter <expr>\n");

    /* Parse the first rexp */
    rexp();

    /* As long as the next token is && or ||, get
    the next token and parse the next rexp */
    while (nextToken == AND_OP || nextToken == OR_OP) {
        lex();
        rexp();
    }

    printf("Exit <expr>\n");
} /* End of function expr */

/* rexp
 * Parses strings in the language generated by the rule:
 * <rexp> -> <aexp> {( == | != | < | > ) <aexp>}
 */
void rexp()
{
    printf("Enter <rexp>\n");

    /* Parse the first aexp */
    aexp();

    /* As long as the next token is == or != or < or >, get
    the next token and parse the next aexp */
    while (nextToken == EQ_OP || nextToken == DIF_OP || nextToken == RB_OP || nextToken == LB_OP) {
        lex();
        aexp();
    }

    printf("Exit <rexp>\n");
} /* End of function rexp */


/* aexp
 * Parses strings in the language generated by the rule:
 * <aexp> -> <term> {(+ | -) <term>}
 */
void aexp()
{
    printf("Enter <aexp>\n");

    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }

    printf("Exit <aexp>\n");
} /* End of function aexp */

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term()
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
        lex();
        factor();
    }
    printf("Exit <term>\n");
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr> ) | !<factor>
 * */
void factor()
{
    printf("Enter <factor>\n");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT) {
        lex(); /* Get the next token */
    }
    else if (nextToken == NOT_OP) {
        lex();
        factor();
    }
    else {
        /* If the RHS is (<expr>), call lex to pass over the
        left parenthesis, call expr, and check for the right
        parenthesis */
        if (nextToken == LEFT_PAREN) {
            lex();
            expr();

            if (nextToken == RIGHT_PAREN) {
                lex();
            }
            else {
                error();
            }
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left parenthesis */
        else
        {
            error();
        }
    } /* End of else */
    printf("Exit <factor>\n");;
} /* End of function factor */

static void error()
{
    printf("Error (more is desired, but not implemented).\n");
}

